#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in5,    ,               sensorLineFollower)
#pragma config(Sensor, in6,    ,               sensorLineFollower)
#pragma config(Sensor, dgtl1,  rightOptics,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  armLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl4,  launcherLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl5,  ultrasonic,     sensorSONAR_inch)
#pragma config(Sensor, dgtl11, leftOptics,     sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  collectorIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightCamIME,    sensorNone)
#pragma config(Sensor, I2C_3,  tensionerIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  rightBaseIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  leftBaseIME,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  leftCamIME,     sensorNone)
#pragma config(Motor,  port1,           tensioner,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port2,           rightFrontBase, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightBackBase, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           rightFrontCam, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightBackCam,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           leftFrontCam,  tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port7,           leftBackCam,   tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_5)
#pragma config(Motor,  port8,           leftFrontBase, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftBackBase,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          collector,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Speeds and other things to make life easier
#define SLOWSPEED 45
#define TENSIONSPEED 127
#define FULLCOURT 100
#define HALFCOURT 2500
#define SHORTCOURT 5000

void setCams(int speed)//Set the Cams to a speed
{
	motor[rightFrontCam] = -speed;
	motor[leftFrontCam] = -speed;
	motor[rightBackCam] = speed;
	motor[leftBackCam] = speed;
}

void driveBaseControl()
{
	if(vexRT[Btn8R] == 1)//5 Up - swivel slowly left
	{
		motor[rightFrontBase] = SLOWSPEED;
		motor[rightBackBase] = SLOWSPEED;
	}
	else if(vexRT[Btn7L] == 1)//6 Up - swivel slowly right
	{
		motor[leftFrontBase] = SLOWSPEED;
		motor[leftBackBase] = SLOWSPEED;
	}
	else if(vexRT[Btn8D] == 1)//6 Down - swivel slowly backwards right
	{
		motor[rightFrontBase] = -SLOWSPEED;
		motor[rightBackBase] = -SLOWSPEED;
	}
	else if(vexRT[Btn7D] == 1)//5 Down - swivel slowly backwards left
	{
		motor[leftFrontBase] = -SLOWSPEED;
		motor[leftBackBase] = -SLOWSPEED;
	}
	else
	{
		motor[rightFrontBase] = vexRT[Ch2];
		motor[rightBackBase] = vexRT[Ch2];
		motor[leftFrontBase] = vexRT[Ch3];
		motor[leftBackBase] = vexRT[Ch3];
	}
}


void auton()//As of now, same as blue auton. Move forward a little and launch 4 balls using 2 limit switches
{
	SensorValue(rightOptics) = 0;
	SensorValue(leftOptics) = 0;
	//resetMotorEncoder();
	//resetMotorEncoder();
//	motor[rightFrontBase] = 35;
//	motor[rightBackBase] = 35;
//	motor[leftFrontBase] = 35;
//	motor[leftBackBase] = 35;
//	wait1Msec(900);
//	motor[rightFrontBase] = 0;
//	motor[rightBackBase] = 0;
//	motor[leftFrontBase] = 0;
//	motor[leftBackBase] = 0;
	//1ST BALL
	/*If the limit switch on the arm is not pressed,
	it wll move the cams until it is, causing the cams to be all the way down.
	Then, it will turn the cams off and wait for 250 milliseconds.*/
	while(SensorValue[armLimitSwitch] != 1)
	{
		setCams(90);
	}
	setCams(0);
	wait1Msec(250);

	/*If the limit switch on the launcher is not pressed,
	it will move the collector until a ball enters and it is.
	Then, it will turn off the collector, wait 250 milliseconds,
	and turn on the cams for 500 milliseconds to launch the ball.*/
	while(SensorValue[launcherLimitSwitch] != 1)
	{
		motor[rightcollector] = 100;
		motor[leftcollector] = 100;
	}
	motor[rightcollector] = 0;
	motor[leftcollector] = 0;
	wait1Msec(700);
	setCams(90);
	wait1Msec(500);
	setCams(0);


	//2ND BALL
	/*If the limit switch on the arm is not pressed,
	it wll move the cams until it is, causing the cams to be all the way down.
	Then, it will turn the cams off and wait for 250 milliseconds.*/
	while(SensorValue[armLimitSwitch] != 1)
	{
		setCams(90);
	}
	setCams(0);
	wait1Msec(250);

	/*If the limit switch on the launcher is not pressed,
	it will move the collector until a ball enters and it is.
	Then, it will turn off the collector, wait 250 milliseconds,
	and turn on the cams for 500 milliseconds to launch the ball.*/
	while(SensorValue[launcherLimitSwitch] != 1)
	{
		motor[rightcollector] = 100;
		motor[leftcollector] = 100;
	}
	motor[rightcollector] = 0;
	motor[leftcollector] = 0;
	wait1Msec(700);
	setCams(90);
	wait1Msec(500);
	setCams(0);


	//3RD BALL
	/*If the limit switch on the arm is not pressed,
	it wll move the cams until it is, causing the cams to be all the way down.
	Then, it will turn the cams off and wait for 250 milliseconds.*/
	while(SensorValue[armLimitSwitch] != 1)
	{
		setCams(90);
	}
	setCams(0);
	wait1Msec(250);

	/*If the limit switch on the launcher is not pressed,
	it will move the collector until a ball enters and it is.
	Then, it will turn off the collector, wait 250 milliseconds,
	and turn on the cams for 500 milliseconds to launch the ball.*/
	while(SensorValue[launcherLimitSwitch] != 1)
	{
		motor[rightcollector] = 100;
		motor[leftcollector] = 100;
	}
	motor[rightcollector] = 0;
	motor[leftcollector] = 0;
	wait1Msec(700);
	setCams(90);
	wait1Msec(500);
	setCams(0);


	//4TH BALL
	/*If the limit switch on the arm is not pressed,
	it wll move the cams until it is, causing the cams to be all the way down.
	Then, it will turn the cams off and wait for 250 milliseconds.*/
	while(SensorValue[armLimitSwitch] != 1)
	{
		setCams(90);
	}
	setCams(0);
	wait1Msec(250);

	/*If the limit switch on the launcher is not pressed,
	it will move the collector until a ball enters and it is.
	Then, it will turn off the collector, wait 250 milliseconds,
	and turn on the cams for 500 milliseconds to launch the ball.*/
	while(SensorValue[launcherLimitSwitch] != 1)
	{
		motor[rightcollector] = 100;
		motor[leftcollector] = 100;
	}
	motor[rightcollector] = 0;
	motor[leftcollector] = 0;
	wait1Msec(700);
	setCams(90);
	wait1Msec(500);
	setCams(0);
	/*If the limit switch on the arm is not pressed,
	it wll move the cams until it is, causing the cams to be all the way down.
	Then, it will turn the cams off and wait for 250 milliseconds.*/
	while(SensorValue[armLimitSwitch] != 1)
	{
		setCams(90);
	}
	setCams(0);
	wait1Msec(250);
	//SensorValue(rightOptics) = 0;
	//SensorValue(leftOptics) = 0;
	//while(SensorValue[rightOptics] < 150)
	//{
		motor[rightFrontBase] = 127;
		motor[rightBackBase] = 127;
		motor[leftFrontBase] = 127;
		motor[leftBackBase] = 127;
		wait1Msec(500);
	//}
	motor[rightFrontBase] = 0;
	motor[rightBackBase] = 0;
	motor[leftFrontBase] = 0;
	motor[leftBackBase] = 0;
}
