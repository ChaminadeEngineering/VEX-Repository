#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpBattery, sensorAnalog)
#pragma config(Sensor, dgtl1,  leftStopButton, sensorTouch)
#pragma config(Sensor, dgtl12, rightStopButton, sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           winchLeft,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightInner,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightOuter,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           leftBase,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           conveyors,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightBase,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftInner,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftOuter,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          winchRight,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

//Define constants for launch speed at sweet spots
#define BAR_SWEETSPOT    40			  //Robot is shooting from the net
#define MID_SWEETSPOT    85			  //Robot is shooting from mid field
#define FULL_SWEETSPOT  100			  //Robot is shooting diagonal from home tile

#define SKILLS_SWEETSPOT 78			  //Robot is shooting from tile to nearest net (opposite color)

#define WAIT_FOR_FLYWHEELS  1000	//Time to wait for flywheel to get to speed while launching balls in autonomous skills
#define WAIT_FOR_BALL_LOAD  1100	//Time to wait between balls while launching in auton skills

//Define constants for LCD
const short LEFT_BUTTON   = 1 ;
const short CENTER_BUTTON = 2 ;
const short RIGHT_BUTTON  = 4 ;

//Define global variables
int iCount = 0 ;																		//Used to remember which auton was selected
int battDependentFull_Court_Sweetspot ;				//Sweetspots as variables so can be changed depending on voltage
int battDependentSkills_Sweetspot     ;
int battDependentHalf_Court_Sweetspot ;
int battDependentBar_Sweetspot        ;
float battVoltage ;

//Add necessary includes
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "LCD_Display.c"								//Battery & message displays
#include "Worlds_Functions.c"						//Motor controls, Auton, driver code


// ********************************************************************
// Pre-Auton section - perform initializations and run LCD selection
// ********************************************************************
void pre_auton()
{
	Auton_Selector() ;										//Use LCD to allow user to select the Auton program to run
	bStopTasksBetweenModes = true ;				//Don't allow tasks to keep running between Auton and Driver mode
}


// ********************************************************************
// Run autonomous program based on user selection from LCD
// The selected program value is stored in iCount
// ********************************************************************
task autonomous()
{
	//Clear the LCD
	bLCDBacklight = true;	clearLCDLine(0);	clearLCDLine(1);

	//Slave flywheel motors to the outer ones which are PID controlled
	slaveMotor(rightInner, rightOuter) ;
	slaveMotor(leftInner,  leftOuter) ;

	//Run an Auton program
	switch(iCount)
	{
		case 0:
			displayLCDCenteredString(0, "Full Court");
			displayLCDCenteredString(1, "is running!");
			Full_Court_Autonomous() ;
			break ;

		case 1:
			displayLCDCenteredString(0, "Bar Auton");
			displayLCDCenteredString(1, "is running!");
			Bar_Autonomous() ;
			break ;

		case 2:
			displayLCDCenteredString(0, "Skills Auton");
			displayLCDCenteredString(1, "is running!");
			Skills_Autonomous();
			break;

		case 3:
			displayLCDCenteredString(0, "NO AUTON");
			displayLCDCenteredString(1, "is running!");
			break;

		default:
			displayLCDCenteredString(0, "Default Full Court");
			displayLCDCenteredString(1, "is running!");
			Full_Court_Autonomous() ;

	} // End of Autonomous switch statement

	//If none of the auton modes are started above, then just run Full Court Auton

}


// ********************************************************************
// Run driver control code
// ********************************************************************
task usercontrol()
{

	string tempS ;
	int timerLock ;
	//Slave flywheel motors to the outer ones which are PID controlled
	slaveMotor(rightInner, rightOuter) ;
	slaveMotor(leftInner,  leftOuter) ;

	clearTimer(T1) ;
	timerLock = time1[T1];

	//Driver control loop
	while(true)
	{

		//~~~~~~~~~~~~~~~ Respond to JOYSTICK commands ~~~~~~~~~~~~~~~~~~~~~~~~~~

		//Control the wheels
		motor[leftBase]  = vexRT(Ch3) ;
		motor[rightBase] = vexRT(Ch2) ;

		//Control intake roller and conveyor motors
		motor[conveyors] = vexRT(Ch3Xmtr2) ;
		motor[intake]    = vexRT(Ch3Xmtr2) ;

		//Pull winch up (lift another bot)
		if(vexRT(Btn8U) == 1 && vexRT(Btn8D) == 0 && vexRT(Btn8L) == 0 && vexRT(Btn8R) == 0)
			{
			motor[winchLeft]  = 122 ;
			motor[winchRight] = 127 ;
			}

		//Stop winch
		else if(vexRT(Btn8U) == 0 && vexRT(Btn8D) == 0 && vexRT(Btn8L) == 0 && vexRT(Btn8R) == 0)
			{
			motor[winchLeft]  = 0 ;
			motor[winchRight] = 0 ;
			}

		//Lower winch to floor
		else if(vexRT(Btn8U) == 0 && vexRT(Btn8D) == 1 && vexRT(Btn8L) == 0 && vexRT(Btn8R) == 0)
			{
			motor[winchLeft]  = -122 ;
			motor[winchRight] = -127 ;
			}

		// Update flywheel speed based on battery voltage every 250 ms
		if(timerLock > 250)
		{
			//Control Flywheels
			if(vexRT(Btn6UXmtr2) == 1 && vexRT(Btn6DXmtr2) == 0 && vexRT(Btn8DXmtr2) == 0) 			//Full court -- 6U = faster
				{
				//Spin_Flywheels(FULL_SWEETSPOT) ;
				battDependentFull_Court_Sweetspot = Lookup_Sweetspot (0) ;
				Spin_Flywheels(battDependentFull_Court_Sweetspot) ;
				}
			else if(vexRT(Btn6UXmtr2) == 0 && vexRT(Btn6DXmtr2) == 1 && vexRT(Btn8DXmtr2) == 0) //Half court -- 6D = slower
				{
				//Spin_Flywheels(MID_SWEETSPOT) ;
				battDependentHalf_Court_Sweetspot = Lookup_Sweetspot (3) ;
				Spin_Flywheels(battDependentHalf_Court_Sweetspot) ;
				}
			else if(vexRT(Btn6UXmtr2) == 0 && vexRT(Btn6DXmtr2) == 0 && vexRT(Btn8DXmtr2) == 1) //Robot is at bar -- 8D = slow
				{
				//Spin_Flywheels(BAR_SWEETSPOT) ;
				battDependentBar_Sweetspot = Lookup_Sweetspot (1) ;
				Spin_Flywheels(battDependentBar_Sweetspot) ;
				}
			else if(vexRT(Btn6UXmtr2) == 0 && vexRT(Btn6DXmtr2) == 0 && vexRT(Btn8DXmtr2) == 0) //Neither button is pressed -- motors are stopped
				{
				Spin_Flywheels(0) ;
				}
			else if(vexRT(Btn6UXmtr2) == 1 && vexRT(Btn6DXmtr2) == 1 && vexRT(Btn8DXmtr2) == 1) //All are pressed -- no confusion -- motors are stopped
				{
				Spin_Flywheels(0) ;
				}

				clearTimer(T1) ;

				//Display current speed (for debug)
				clearLCDLine(0) ;	clearLCDLine(1) ;

				stringFormat(tempS, "%1.2f", battVoltage);
				displayLCDString(0, 1, "Batt: ");
				displayLCDString(0, 7,tempS);
				stringFormat(tempS, "%1.2f", battDependentFull_Court_Sweetspot);
				displayLCDString(1, 1, "Speed: ");
				displayLCDString(1, 8,tempS);

			} // End of timerLock if statement

			timerLock = time1[T1] ;

		} //End of Driver Control While loop
}	//End of usercontrol task
