#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in8,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  Touch,          sensorTouch)
#pragma config(Sensor, dgtl2,  Yellow,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  Green,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LED3,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           CL,            tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           BLFBLB,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           BLM,           tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           SLF,           tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port5,           SLB,           tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port6,           SRB,           tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_6)
#pragma config(Motor,  port7,           SRF,           tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_5)
#pragma config(Motor,  port8,           BRM,           tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port9,           BRFBRB,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          CR,            tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)


#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;


int count = 0;
int inch = 30;

int speed;
const int MAXSPEED = 127;
//End of the drive bools and ints//

//auton time left int
/*time left = 15sec*/int autonomous_timeleft = 14800;
//
//bool pressed
bool pressed = false;
bool prevPress = false;
bool yellowlight = false;
//
int yellowTime = 0;

int backUpLowSpeed = 50;
int lowSpeed = 40;
int medSpeed = 60;
int backUpMedSpeed = 68;
int highSpeed = 110;

bool prevPushed = false;

void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}

void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}

void selector()
{

	bLCDBacklight = true;

	clearLCDLine(0);
	clearLCDLine(1);
	int count = 0;
	while(nLCDButtons != centerButton)
	{

		switch(count){
		case 0:
			displayLCDCenteredString(0, "Full Court Auton");
			displayLCDCenteredString(1, "<     Enter    >");
			waitForPress();

			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 2;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			displayLCDCenteredString(0, "Low Post Shot");
			displayLCDCenteredString(1, "<     Enter    >");
			waitForPress();

			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:

			displayLCDCenteredString(0, "Driver Contorl");
			displayLCDCenteredString(1, "<     Enter    >");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		case 3:

			displayLCDCenteredString(0, "Auton Skills");
			displayLCDCenteredString(1, "<     Enter    >");
			waitForPress();

			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
			/*
			case 4:

			displayLCDCenteredString(0, "Autonomous Skills");
			displayLCDCenteredString(1, "<     Enter    >");
			waitForPress();

			if(nLCDButtons == leftButton)
			{
			waitForRelease();
			count--;
			}
			else if(nLCDButtons == rightButton)
			{
			waitForRelease();
			count ++;
			}
			break;

			case 5:

			displayLCDCenteredString(0, "Practice Mode");
			displayLCDCenteredString(1, "<     Enter    >");
			waitForPress();


			if(nLCDButtons == leftButton)
			{
			waitForRelease();
			count--;
			}
			else if(nLCDButtons == rightButton)
			{
			waitForRelease();
			count = 0;
			}
			break;
			*/
			/*default:
			count = 0;
			break;*/

		}
	}


}
void pre_auton()
{
	selector();
}

task autonomous()
{
	//LED to 0
	//SensorValue[LED] = 0;
	//
	bLCDBacklight = true;
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Full Court");
		displayLCDCenteredString(1, "is running!");


		//only do this in skills
		/**/
		motor[BLFBLB] = 127;
		motor[BLM] = 127;
		motor[BRM] = 127;
		motor[BRFBRB] = 127;
		wait1Msec(200);
		/*motor[BLFBLB] = -127;
		motor[BLM] = -127;
		motor[BRM] = 127;
		motor[BRFBRB] = 127;
		wait1Msec(150);//**/
		motor[BLFBLB] = 0;
		motor[BLM] = 0;
		motor[BRM] = 0;
		motor[BRFBRB] = 0;
		//start shooter
		/*motor[SLB] = -75;
		motor[SLF] = -75;
		motor[SRB] = -75;
		motor[SRF] = -75;
		//**/
		//start shooter
		motor[SLB] = -127;
		motor[SLF] = -127;
		motor[SRB] = -127;
		motor[SRF] = -127;
		//go for 2 sec*/
		wait1Msec(3000);
		//collectors bring balls up
		motor[CR] = -80;
		motor[CL] = 100;
		//wait till end
		wait1Msec(57000);
		//set motors to off
		//collectors
		motor[CL] = 0;
		motor[CR] = 0;
		//base
		motor[SLB] = 0;
		motor[SLF] = 0;
		motor[SRB] = 0;
		motor[SRF] = 0;

		break;


	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Low Post Shot");
		displayLCDCenteredString(1, "is running!");

		//wait
		wait1Msec(2000);
		// move forward
		motor[BLFBLB] = 127;
		motor[BLM] = 127;
		motor[BRM] = 127;
		motor[BRFBRB] = 127;
		// for this time
		wait1Msec(3500);
		// stop motors
		motor[BLFBLB] = 0;
		motor[BLM] = 0;
		motor[BRM] = 0;
		motor[BRFBRB] = 0;
		//start shooter
		motor[SLB] = -110;
		motor[SLF] = -110;
		motor[SRB] = -110;
		motor[SRF] = -110;
		//go for 2 sec
		wait1Msec(3000);
		//collectors bring balls up
		motor[CR] = -80;
		motor[CL] = 127;
		//wait till end
		wait1Msec(13000);
		//set motors to off
		//collectors
		motor[CL] = 0;
		motor[CR] = 0;
		//base
		motor[SLB] = 0;
		motor[SLF] = 0;
		motor[SRB] = 0;
		motor[SRF] = 0;

		break;
	case 2:
		displayLCDCenteredString(0, "Driver");
		displayLCDCenteredString(1, "is running!");

		startTask(usercontrol);

		break;

	case 3:
		displayLCDCenteredString(0, "Red Left Square");
		displayLCDCenteredString(1, "is running!");

		displayLCDCenteredString(0, "Full Court");
		displayLCDCenteredString(1, "is running!");


		//only do this in skills
		/**/
		motor[BLFBLB] = -127;
		motor[BLM] = -127;
		motor[BRM] = -127;
		motor[BRFBRB] = -127;
		wait1Msec(500);
		motor[BLFBLB] = -127;
		motor[BLM] = -127;
		motor[BRM] = 127;
		motor[BRFBRB] = 127;
		wait1Msec(150);
		motor[BLFBLB] = 0;
		motor[BLM] = 0;
		motor[BRM] = 0;
		motor[BRFBRB] = 0;
		/**/
		//start shooter
		motor[SLB] = -115;
		motor[SLF] = -115;
		motor[SRB] = -115;
		motor[SRF] = -115;
		//go for 2 sec
		wait1Msec(3000);
		//collectors bring balls up
		motor[CR] = -80;
		motor[CL] = 100;
		//wait till end
		wait1Msec(57000);
		//set motors to off
		//collectors
		motor[CL] = 0;
		motor[CR] = 0;
		//base
		motor[SLB] = 0;
		motor[SLF] = 0;
		motor[SRB] = 0;
		motor[SRF] = 0;

		break;
		/*
		case 4:
		displayLCDCenteredString(0, "Blue Left Square");
		displayLCDCenteredString(1, "is running!");

		clearTimer(T1);

		//nMotorEncoder[BLFBLB] = 0;

		motor[BLFBLB] = 127;
		motor[BLM] = 127;
		motor[BRM] = 127;
		motor[BRFBRB] = 127;
		motor[CL] = -127;
		wait1Msec(3500);

		motor[BLFBLB] = 0;
		motor[BLM] = 0;
		motor[BRFBRB] = 0;
		motor[BRM] = 0;
		motor[CL] = 0;
		while(true)
		{
		//warp up shooter
		motor[SLB] = -70;
		motor[SLF] = -70;
		motor[SRB] = -70;
		motor[SRF] = -70;
		wait1Msec(1000);
		while(autonomous_timeleft - time1[T1] >= 2000)
		{
		//move balls to shooter
		motor[CR] = 127;
		//shooter
		motor[SLB] = -70;
		motor[SLF] = -70;
		motor[SRB] = -70;
		motor[SRF] = -70;
		}
		break;
		}
		break;
		case 5:
		displayLCDCenteredString(0, "Practice Mode");
		displayLCDCenteredString(1, "is running!");


		startTask(usercontrol);


		break;

		}*/
		/*
		displayLCDCenteredString(0, "Blue Left Square");
		displayLCDCenteredString(1, "is running!");

		//clear timer 1
		clearTimer(T1);

		//nMotorEncoder[BLFBLB] = 0;
		//wait 2 sec before starting
		wait1Msec(2000);
		//Drive forward
		motor[BLFBLB] = 127;
		motor[BLM] = 127;
		motor[BRM] = 127;
		motor[BRFBRB] = 127;
		//collect at same time
		motor[CL] = -127;
		wait1Msec(2750);

		//stop motors
		motor[BLFBLB] = 0;
		motor[BLM] = 0;
		motor[BRFBRB] = 0;
		motor[BRM] = 0;
		motor[CL] = 0;
		while(true)
		{
		//warp up shooter
		motor[SLB] = -60;
		motor[SLF] = -60;
		motor[SRB] = -60;
		motor[SRF] = -60;
		wait1Msec(2000);

		//shot while there is more than two seconds left of autonomous
		while(autonomous_timeleft - time1[T1] >= 1000)
		{

		//move balls to shooter
		motor[CR] = 100;
		//shooter
		motor[SLB] = -60;
		motor[SLF] = -60;
		motor[SRB] = -60;
		motor[SRF] = -60;
		wait1Msec(1500);
		motor[CR] = 0;
		wait1Msec(1000);
		motor[CR] = 100;
		wait1Msec(1500);
		motor[CR] = 0;
		wait1Msec(1000);
		motor[CR] = 100;
		break;

		}
		while(autonomous_timeleft - time1[T1] <= 1000)
		{
		//stop motors
		motor[CR] = 0;
		motor[SLB] = 0;
		motor[SLF] = 0;
		motor[SRB] = 0;
		motor[SRF] = 0;

		// move back
		motor[BLFBLB] = -127;
		motor[BLM] = -127;
		motor[BRM] = -127;
		motor[BRFBRB] = -127;
		// for this time
		wait1Msec(250);
		// stop motors
		motor[BLFBLB] = 0;
		motor[BLM] = 0;
		motor[BRM] = 0;
		motor[BRFBRB] = 0;
		break;
		}
		}
		/*
		//clear Timer
		clearTimer(T1);
		//warp up shooter for 3 sec
		motor[SLB] = -127;
		motor[SLF] = -127;
		motor[SRB] = -127;
		motor[SRF] = -127;
		//3 sec
		wait1Msec(3000);

		//while the time left in autonomous is greater than 5 sec
		while(autonomous_timeleft - time1[T1] >= 4800)
		{
		//shooter going from above
		//start collecter and bring up balls
		motor[CR] = 127;
		}
		//stop all motors
		motor[CR] = 0;
		motor[SLB] = 0;
		motor[SLF] = 0;
		motor[SRB] = 0;
		motor[SRF] = 0;

		bLCDBacklight = true;
		switch (count){
		case 0:

		//start shooter
		motor[SLB] = -110;
		motor[SLF] = -110;
		motor[SRB] = -110;
		motor[SRF] = -110;
		//go for 2 sec
		wait1Msec(3000);
		//collectors bring balls up
		motor[CR] = -80;
		motor[CL] = 127;
		//wait till end
		wait1Msec(13000);
		//set motors to off
		//collectors
		motor[CL] = 0;
		motor[CR] = 0;
		//base
		motor[SLB] = 0;
		motor[SLF] = 0;
		motor[SRB] = 0;
		motor[SRF] = 0;

		break;
		case 1:

		//wait
		wait1Msec(2000);
		// move forward
		motor[BLFBLB] = 127;
		motor[BLM] = 127;
		motor[BRM] = 127;
		motor[BRFBRB] = 127;
		// for this time
		wait1Msec(3500);
		// stop motors
		motor[BLFBLB] = 0;
		motor[BLM] = 0;
		motor[BRM] = 0;
		motor[BRFBRB] = 0;
		//start shooter
		motor[SLB] = -60;
		motor[SLF] = -60;
		motor[SRB] = -60;
		motor[SRF] = -60;
		//go for 2 sec
		wait1Msec(3000);
		//collectors bring balls up
		motor[CR] = -80;
		motor[CL] = 127;
		//wait till end
		wait1Msec(13000);
		//set motors to off
		//collectors
		motor[CL] = 0;
		motor[CR] = 0;
		//base
		motor[SLB] = 0;
		motor[SLF] = 0;
		motor[SRB] = 0;
		motor[SRF] = 0;

		case 2:

		startTask(usercontrol);
		break;

		*/

	}

}







task usercontrol()
{
	//LED to 0
	//SensorValue[Red] = 0 ;
	SensorValue[Yellow] = 0 ;
	SensorValue[Green] = 0;
	//

	bLCDBacklight = true;

	int prevValue;
	int currentValue;
	nMotorEncoder[SLB] = 0;
	nMotorEncoder[SLF] = 0;
	nMotorEncoder[SRB] = 0;
	nMotorEncoder[SRF] = 0;

	while (true)
	{
		string mainBattery, backupBattery;

		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayNextLCDString(mainBattery);
		//Display the Backup battery voltage
		displayLCDString(1, 0, "Backup: ");
		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');    //Build the value to be displayed
		displayNextLCDString(backupBattery);

		//drive
		motor[BLFBLB] = vexRT[Ch3];
		motor[BLM] = vexRT[Ch3];
		motor[BRFBRB] = vexRT[Ch2];
		motor[BRM] = vexRT[Ch2];
		//Shooter and Collector
		//motor[CL] = vexRT[Ch3Xmtr2];
		//motor[CR] = vexRT[Ch3Xmtr2];






		/*	if(vexRT[Btn8DXmtr2] == 1)
		{

		speed = 48;
		motor[SLF] = speed;
		motor[SLB] = speed;
		motor[SRB] = speed;
		motor[SRF] = speed;

		while(speed < MAXSPEED)
		{
		speed++;
		wait1Msec(100);
		}

		}*/
		//shoot below
		if(vexRT[Btn8UXmtr2] == 1)
		{



			//Full court
			motor[SLF] = -highSpeed;
			motor[SLB] = -highSpeed;
			motor[SRB] = -highSpeed;
			motor[SRF] = -highSpeed;
			pressed = true;
		}

		else if(vexRT[Btn8LXmtr2] == 1)
		{

			//half court
			motor[SLF] = -medSpeed;
			motor[SLB] = -medSpeed;
			motor[SRB] = -medSpeed;
			motor[SRF] = -medSpeed;
			pressed = true;

		}
		else if(vexRT[Btn8DXmtr2] == 1)
		{

			//layup
			motor[SLF] = -lowSpeed;
			motor[SLB] = -lowSpeed;
			motor[SRB] = -lowSpeed;
			motor[SRF] = -lowSpeed;
			pressed = true;

		}
		else if(vexRT[Btn7DXmtr2] == 1)
		{
						//layup lower
			motor[SLF] = -backUpLowSpeed;
			motor[SLB] = -backUpLowSpeed;
			motor[SRB] = -backUpLowSpeed;
			motor[SRF] = -backUpLowSpeed;
			pressed = true;
		}
		else if(vexRT[Btn7LXmtr2] == 1)
		{
						//layup lower
			motor[SLF] = -backUpMedSpeed;
			motor[SLB] = -backUpMedSpeed;
			motor[SRB] = -backUpMedSpeed;
			motor[SRF] = -backUpMedSpeed;
			pressed = true;
		}
		else if (vexRT[Btn8RXmtr2] == 1)
		{
			motor[SLF] = 0;
			motor[SLB] = 0;
			motor[SRB] = 0;
			motor[SRF] = 0;
			pressed = false;
		}/*
		if (vexRT[Btn7DXmtr2] == 1)
		{
		lowSpeed -= 5;
		medSpeed -= 5;
		highSpeed -= 5;
		}
		else if(vexRT[Btn7UXmtr2] ==1)
		{
		lowSpeed += 5;
		medSpeed += 5;
		highSpeed += 5;
		}*/



		//more shooter
		if(pressed == false)
		{
			motor[SLF] = -vexRT[Ch2Xmtr2];
			motor[SLB] = -vexRT[Ch2Xmtr2];
			motor[SRB] = -vexRT[Ch2Xmtr2];
			motor[SRF] = -vexRT[Ch2Xmtr2];
		}

		/*if(vexRT[Btn8U] == 1)
		{
			motor[BLFBLB] = 40;
			motor[BLM] = 40;
			motor[BRM] = -40;
			motor[BRFBRB] = -40;
		}
		else if(vexRT[Btn8D] == 1)
		{
			motor[BLFBLB] = -40;
			motor[BLM] = -40;
			motor[BRM] = 40;
			motor[BRFBRB] = 40;
		}
		else if(vexRT[Btn8L] == 1)
		{
			motor[BLFBLB] = -40;
			motor[BLM] = -40;
			motor[BRM] = -40;
			motor[BRFBRB] = -40;
		}
		else if(vexRT[Btn8R] == 1)
		{
			motor[BLFBLB] = 40;
			motor[BLM] = 40;
			motor[BRM] = 40;
			motor[BRFBRB] = 40;
		}
		else
		{
		motor[BLFBLB] = vexRT[Ch3];
		motor[BLM] = vexRT[Ch3];
		motor[BRFBRB] = vexRT[Ch2];
		motor[BRM] = vexRT[Ch2];
		}*/


		//CL
		if(vexRT[Btn5UXmtr2] == 1)
		{

			motor[CR] = 127;

		}
		else if(vexRT[Btn5DXmtr2] == 1)
		{

			motor[CR] = -127;

		}
		else
		{

			motor[CR] = 0;

		}

		//CR
		if(vexRT[Btn6UXmtr2] == 1)
		{

			motor[CL] = 127;

		}
		else if(vexRT[Btn6DXmtr2] == 1)
		{

			motor[CL] = -127;

		}
		else
		{

			motor[CL] = 0;

		}

		/*if(abs(nMotorEncoder[SLB]) < 2 && pressed == true|| abs(nMotorEncoder[SRB]) < 2 && pressed == true)
		{
		lowSpeed++;
		}*/
		if(!pressed)
		{
			//SensorValue[Red] = 1;
			SensorValue[Yellow] = 0;
			SensorValue[Green] = 0;
		}
		else if(pressed && !prevPress)
		{
			SensorValue[Yellow] = 1;
			SensorValue[Red] = 0;
			SensorValue[Green] = 0;
			yellowlight = true;
		}
		else
		{
			if(yellowlight == true && yellowTime <= 100)
			{
				SensorValue[Green] = 0;
				SensorValue[Red] = 0;
				SensorValue[Yellow] = 1;
				yellowtime++;
			}
			else
			{
				SensorValue[Green] = 1;
				SensorValue[Red] = 0;
				SensorValue[Yellow] = 0;
				yellowlight = false;
				yellowTime = 0;
			}
		}
		prevPress = pressed;
	}
}
