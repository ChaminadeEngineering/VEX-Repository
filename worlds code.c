#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           RubberbandCollector, tmotorVex393_HBridge, openLoop, encoderPort, I2C_6)
#pragma config(Motor,  port2,           FlyWheelTopBottom, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           FlywheelMiddle, tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port4,           BLF,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           BLB,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           BRF,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           BRB,           tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port8,           PuncherMid,    tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port9,           PuncherTopBottom, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          BallConveyor,  tmotorVex393_HBridge, openLoop, encoderPort, I2C_5)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int lowSpeed = 70;
int medSpeed = 90;
int highSpeed = 100;

int count = 0;

bool pressed = false;

#pragma platform(VEX)

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}

void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}

void selector()
{

	bLCDBacklight = true;

	clearLCDLine(0);
	clearLCDLine(1);
	int count = 0;
	while(nLCDButtons != centerButton)
	{

		switch(count){
		case 0:
			displayLCDCenteredString(0, "Full Court Auton");
			displayLCDCenteredString(1, "<     Enter    >");
			waitForPress();

			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 2;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			displayLCDCenteredString(0, "Low Post Shot");
			displayLCDCenteredString(1, "<     Enter    >");
			waitForPress();

			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:

			displayLCDCenteredString(0, "Driver Contorl");
			displayLCDCenteredString(1, "<     Enter    >");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		case 3:

			displayLCDCenteredString(0, "Auton Skills");
			displayLCDCenteredString(1, "<     Enter    >");
			waitForPress();

			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count=0;
			break;
		}
	}
}

	void pre_auton()
	{
 		selector();
	}

	task autonomous()
	{
		switch(count){
			case 0://auton
				motor[PuncherMid] = 120;
				motor[PuncherTopBottom] = 120;
				wait1Msec(7000);
				motor[PuncherMid] = 0;
				motor[PuncherTopBottom] = 0;
			break;

			case 1:

			break;

			case 2:
			startTask(usercontrol);
			break;

			case 3:

			break;
		}
	}

	task usercontrol()
	{


		while (true)
		{

			//base
			motor[BLF] = vexRT[Ch3];
			motor[BLB] = vexRT[Ch3];
			motor[BRF] = vexRT[Ch2];
			motor[BRB] = vexRT[Ch2];

			//colectors
			//CL
			if(vexRT[Btn5U] == 1)
			{

				motor[RubberbandCollector] = 127;

			}
			else if(vexRT[Btn5D] == 1)
			{

				motor[RubberbandCollector] = -127;

			}
			else
			{

				motor[RubberbandCollector] = 0;

			}

			//CR
			if(vexRT[Btn6U] == 1)
			{

				motor[BallConveyor] = 127;

			}
			else if(vexRT[Btn6D] == 1)
			{

				motor[BallConveyor] = -127;

			}
			else
			{

				motor[BallConveyor] = 0;

			}
			//puncher
			if(vexRT[Btn8U] == 1)
			{

				motor[PuncherMid] = 127;
				motor[PuncherTopBottom] = 127;
			}
			else if(vexRT[Btn8U] != 1)
			{
				motor[PuncherMid] = 0;
				motor[PuncherTopBottom] = 0;
			}

			else
			{

				motor[PuncherMid] = 0;
				motor[PuncherMid] = 0;

			}

			//shooter
			if(vexRT[Btn8UXmtr2] == 1)
			{



				//Full court
				motor[FlyWheelTopBottom] = -highSpeed;
				motor[FlywheelMiddle] = -highSpeed;
				pressed = true;
			}

			else if(vexRT[Btn8LXmtr2] == 1)
			{

				//half court
				motor[FlywheelMiddle] = -medSpeed;
				motor[FlyWheelTopBottom] = -medSpeed;
				pressed = true;

			}
			else if(vexRT[Btn8DXmtr2] == 1)
			{

				//layup
				motor[FlywheelMiddle] = -lowSpeed;
				motor[FlyWheelTopBottom] = -lowSpeed;
				pressed = true;

			}
			else if (vexRT[Btn8RXmtr2] == 1)
			{
				motor[FlywheelMiddle] = 0;
				motor[FlyWheelTopBottom] = 0;
				pressed = false;
			}

			//reverse slow
			if(pressed == false && vexRT[Btn7D] == 1)
			{
				motor[FlywheelMiddle] = 30;
				motor[FlyWheelTopBottom] = 30;
			}
			else if(pressed == false && vexRT[Btn7D] != 1)
			{
				motor[FlywheelMiddle] = 0;
				motor[FlyWheelTopBottom] = 0;
			}

		}
	}
