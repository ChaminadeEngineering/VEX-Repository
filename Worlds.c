#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in4,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in5,    ,               sensorLineFollower)
#pragma config(Sensor, in6,    ,               sensorLineFollower)
#pragma config(Sensor, dgtl1,  rightOptics,    sensorRotation)
#pragma config(Sensor, dgtl2,  leftOptics,     sensorRotation)
#pragma config(Sensor, dgtl3,  armLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl4,  launcherLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl5,  LEDLine,        sensorDigitalOut)
#pragma config(Sensor, dgtl12, ,               sensorDigitalOut)
#pragma config(Sensor, I2C_1,  collectorIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightBaseIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  leftBaseIME,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  rightBaseIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  leftBaseIME,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  leftCamIME,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           frontcollector, tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port2,           rightFrontBase, tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port3,           rightBackBase, tmotorVex393_MC29, openLoop, encoderPort, I2C_6)
#pragma config(Motor,  port4,           rightFrontCam, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rightBackCam,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           leftFrontCam,  tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port7,           leftBackCam,   tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port8,           leftFrontBase, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftBackBase,  tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port10,          backcollector, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
1: The basic code that has everything it needs as of now
*/

#define CAMSPEED 127 //This is the speed of the cams, later used in the code
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "New_Autons_And_Functions.c"

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	//Resetting the gyro
	SensorType[gyro] = sensorNone;
	wait1Msec(1000);
	SensorType[gyro] = sensorGyro;
	wait1Msec(1000);

	bStopTasksBetweenModes = true;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	//auton(); //See "New_Autons_And_Functions.c"
	skills(); //See "New_Autons_And_Functions.c"
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	bool EPL = false; //EPL is when we run the CAMS for a long time to launch balls being loaded by hand
	int initialGyroValue = 0; //See button 5UXmtr2 below
	const int deadBandLimit = 5; //See if statements after collector and drive base control
	/*
	Joystick Map:
	- 5U sets gyroAdjust to false (see "New_Autons_And_Functions.c")
	- 5D sets gyroAdjust to true (see "New_Autons_And_Functions.c")
	- 6UXmtr2 sets EPL to false and then runs the CAMS until they are reset and ready to collect a ball (when armLimitSwitch is pressed)
	- 8DXmtr2 sets EPL to false, launches a ball by running the CAMS, and runs the CAMS until they are reset and ready to collect a ball
	- 8RXmtr2 does the same as 8DXmtr2, and then runs the collector until a ball is in the CAMS ready to launch, or 8UXmtr2 is pressed (force out of loop)
	- 5UXmtr2 and 6U set EPL to true, save the value of the gyro, adjust the gyro (if needed and if gyroAdjust is true), and then run the CAMS for EPL
	- Channel 3Xmtr2 and Channel 2Xmtr2 run backcollector and frontcollector, in that order
	- The if statement that comes afterwards tests if either of the collectors are running and if they are, sets EPL to false
	- driveBaseControl (see "New_Autons_And_Functions.c") runs the base on Channels 3 and 2
	- The if statement that comes afterwards tests if either sides of the base are running and if they are, sets EPL to false
	*/
	while(true)
	{
		if(vexRT[Btn5U] == 1) //Sets gyroAdjust to false
		{
			gyroAdjust = false;
		}

		else if(vexRT[Btn5D] == 1) //Sets gyroAdjust to true
		{
			gyroAdjust = true;
		}

		if(vexRT[Btn6UXmtr2] == 1) //Sets EPL to false and runs CAMS until armLimitSwitch is pressed
		{
			EPL = false;
			while(SensorValue[armLimitSwitch] != 1)
			{
				//Drive Base Logic
				driveBaseControl();
				motor[leftFrontCam] = -127;
				motor[rightFrontCam] = -127;
				motor[leftBackCam] = 127;
				motor[rightBackCam] = 127;
			}
			motor[rightFrontCam] = 0;
			motor[leftFrontCam] = 0;
			motor[rightBackCam] = 0;
			motor[leftBackCam] = 0;
		}

		if(vexRT[Btn8DXmtr2] == 1) //Sets EPL to false, launches ball, and runs CAMS until armLimitSwitch is pressed
		{
			EPL = false;
			motor[leftFrontCam] = -127;
			motor[rightFrontCam] = -127;
			motor[leftBackCam] = 127;
			motor[rightBackCam] = 127;
			wait1Msec(200);
			while(SensorValue[armLimitSwitch] != 1)
			{
				//Drive Base Logic
				driveBaseControl();
				motor[leftFrontCam] = -127;
				motor[rightFrontCam] = -127;
				motor[leftBackCam] = 127;
				motor[rightBackCam] = 127;
			}
			motor[rightFrontCam] = 0;
			motor[leftFrontCam] = 0;
			motor[rightBackCam] = 0;
			motor[leftBackCam] = 0;
		}

		if(vexRT[Btn8RXmtr2] == 1) //Sets EPL to false, launches ball, runs CAMS until armLimitSwitch is pressed, and then runs collectors until launcherLimitSwitch or 8UXmtr2 is pressed
		{
			EPL = false;
			motor[leftFrontCam] = -127;
			motor[rightFrontCam] = -127;
			motor[leftBackCam] = 127;
			motor[rightBackCam] = 127;
			wait1Msec(200);
			while(SensorValue[armLimitSwitch] != 1)
			{
				//Drive Base Logic
				driveBaseControl();
				motor[leftFrontCam] = -127;
				motor[rightFrontCam] = -127;
				motor[leftBackCam] = 127;
				motor[rightBackCam] = 127;
			}
			motor[rightFrontCam] = 0;
			motor[leftFrontCam] = 0;
			motor[rightBackCam] = 0;
			motor[leftBackCam] = 0;
			int count = 1;
			while(SensorValue[launcherLimitSwitch] != 1 && count == 1)
			{
				driveBaseControl();
				motor[backcollector] = 127;
				motor[frontcollector] = 127;
				if(vexRT[Btn8UXmtr2] == 1)
				{
					count = 0;
				}
			}
			motor[backcollector] = 0;
			motor[frontcollector] = 0;
		}

		if(vexRT[Btn5UXmtr2] == 1 || vexRT[Btn6U] == 1) //Sets EPL to true, saves the value of the gyro, and if gyroAdjust is true, adjusts the base. If not, runs the CAMS manually for EPL (see EPL above and "New_Autons_And_Functions.c" for variables)
		{
			if(EPL == false)
			{
				EPL = true;
				initialGyroValue = SensorValue[gyro];
			}
			if(gyroAdjust == true)
			{
				adjustForJiggle(initialGyroValue);
			}
			motor[rightFrontCam] = -CAMSPEED;
			motor[leftFrontCam] = -CAMSPEED;
			motor[rightBackCam] = CAMSPEED;
			motor[leftBackCam] = CAMSPEED;
		}
		else
		{
			motor[rightFrontCam] = 0;
			motor[leftFrontCam] = 0;
			motor[rightBackCam] = 0;
			motor[leftBackCam] = 0;
		}

		//Collector control
		motor[backcollector] = -vexRT[Ch3Xmtr2];
		motor[frontcollector] = -vexRT[Ch2Xmtr2];

		//Test collector for EPL
		if(vexRT[Ch3Xmtr2] > deadBandLimit || vexRT[Ch3Xmtr2] < -deadBandLimit || vexRT[Ch2Xmtr2] > deadBandLimit || vexRT[Ch2Xmtr2] < -deadBandLimit)
		{
			EPL = false;
		}

		driveBaseControl();//Runs the base. See "New_Autons_And_Functions.c"

		//Test base for EPL
		if(vexRT[Ch3] > deadBandLimit || vexRT[Ch3] < -deadBandLimit || vexRT[Ch2] > deadBandLimit || vexRT[Ch2] < -deadBandLimit)
		{
			EPL = false;
		}
	}
}
