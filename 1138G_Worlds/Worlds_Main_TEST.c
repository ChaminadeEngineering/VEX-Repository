#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpBattery, sensorAnalog)
#pragma config(Sensor, dgtl1,  leftStopButton, sensorTouch)
#pragma config(Sensor, dgtl12, rightStopButton, sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           winchLeft,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightInner,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightOuter,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           leftBase,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           conveyors,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightBase,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftInner,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftOuter,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          winchRight,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**/


#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

//Define constants for launch speed at sweet spots
#define BAR_SWEETSPOT    40			  //Robot is shooting from the net
#define MID_SWEETSPOT    85			  //Robot is shooting from mid field
#define FULL_SWEETSPOT  100			  //Robot is shooting diagonal from home tile

#define SKILLS_SWEETSPOT 78			  //Robot is shooting from tile to nearest net (opposite color)

#define WAIT_FOR_FLYWHEELS  1000	//Time to wait for flywheel to get to speed while launching balls in autonomous skills
#define WAIT_FOR_BALL_LOAD  1100	//Time to wait between balls while launching in auton skills

//Define constants for LCD
const short LEFT_BUTTON   = 1 ;
const short CENTER_BUTTON = 2 ;
const short RIGHT_BUTTON  = 4 ;

//Define global variables
int iCount = 0 ;																		//Used to remember which auton was selected
int battDependentFull_Court_Sweetspot ;				//Sweetspots as variables so can be changed depending on voltage
float battDependentSkills_Sweetspot = 45   ;
int battDependentHalf_Court_Sweetspot ;
int battDependentBar_Sweetspot        ;
float battVoltage ;
float mainVoltage ;

//Add necessary includes
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "LCD_Display.c"								//Battery & message displays
#include "Worlds_Functions.c"						//Motor controls, Auton, driver code


// ********************************************************************
// Pre-Auton section - perform initializations and run LCD selection
// ********************************************************************
void pre_auton()
{
	Auton_Selector() ;										//Use LCD to allow user to select the Auton program to run
	bStopTasksBetweenModes = true ;				//Don't allow tasks to keep running between Auton and Driver mode
}


// ********************************************************************
// Run autonomous program based on user selection from LCD
// The selected program value is stored in iCount
// ********************************************************************
task autonomous()
{
	//Clear the LCD
	bLCDBacklight = true;	clearLCDLine(0);	clearLCDLine(1);

	//Slave flywheel motors to the outer ones which are PID controlled
	slaveMotor(rightInner, rightOuter) ;
	slaveMotor(leftInner,  leftOuter) ;

	//Run an Auton program
	switch(iCount)
	{
		case 0:
			displayLCDCenteredString(0, "Full Court");
			displayLCDCenteredString(1, "is running!");
			Full_Court_Autonomous() ;
			break ;

		case 1:
			displayLCDCenteredString(0, "Bar Auton");
			displayLCDCenteredString(1, "is running!");
			Bar_Autonomous() ;
			break ;

		case 2:
			displayLCDCenteredString(0, "Skills Auton");
			displayLCDCenteredString(1, "is running!");
			Skills_Autonomous();
			break;

		case 3:
			displayLCDCenteredString(0, "NO AUTON");
			displayLCDCenteredString(1, "is running!");
			break;

		default:
			displayLCDCenteredString(0, "Default Full Court");
			displayLCDCenteredString(1, "is running!");
			Full_Court_Autonomous() ;

	} // End of Autonomous switch statement

	//If none of the auton modes are started above, then just run Full Court Auton

}


// ********************************************************************
// Run driver control code
// ********************************************************************
task usercontrol()
{

	string fullS ;
	string halfS ;
	string skillS ;
	int timerLock ;
	//Slave flywheel motors to the outer ones which are PID controlled
	slaveMotor(rightInner, rightOuter) ;
	slaveMotor(leftInner,  leftOuter) ;

	clearTimer(T1) ;
	timerLock = time1[T1];

	//Driver control loop
	while(true)
	{


		//~~~~~~~~~~~~~~~ Respond to JOYSTICK commands ~~~~~~~~~~~~~~~~~~~~~~~~~~

		//Control the wheels
		//motor[leftBase]  = vexRT(Ch3) ;
		//motor[rightBase] = vexRT(Ch2) ;

		////Control intake roller and conveyor motors
		//motor[conveyors] = vexRT(Ch3Xmtr2) ;
		//motor[intake]    = vexRT(Ch3Xmtr2) ;

		////Pull winch up (lift another bot)
		//if(vexRT(Btn8U) == 1 && vexRT(Btn8D) == 0 && vexRT(Btn8L) == 0 && vexRT(Btn8R) == 0)
		//	{
		//	motor[winchLeft]  = 122 ;
		//	motor[winchRight] = 127 ;
		//	}

		////Stop winch
		//else if(vexRT(Btn8U) == 0 && vexRT(Btn8D) == 0 && vexRT(Btn8L) == 0 && vexRT(Btn8R) == 0)
		//	{
		//	motor[winchLeft]  = 0 ;
		//	motor[winchRight] = 0 ;
		//	}

		////Lower winch to floor
		//else if(vexRT(Btn8U) == 0 && vexRT(Btn8D) == 1 && vexRT(Btn8L) == 0 && vexRT(Btn8R) == 0)
		//	{
		//	motor[winchLeft]  = -122 ;
		//	motor[winchRight] = -127 ;
		//	}

		//// Update flywheel speed based on battery voltage every 250 ms
		if(timerLock > 250)
		{
		//	//Control Flywheels
		//	if(vexRT(Btn6UXmtr2) == 1 && vexRT(Btn6DXmtr2) == 0 && vexRT(Btn8DXmtr2) == 0) 			//Full court -- 6U = faster
		//		{
		//		//Spin_Flywheels(FULL_SWEETSPOT) ;
		//		battDependentFull_Court_Sweetspot = Lookup_Sweetspot (0) ;
		//		Spin_Flywheels(battDependentFull_Court_Sweetspot) ;
		//		}
		//	else if(vexRT(Btn6UXmtr2) == 0 && vexRT(Btn6DXmtr2) == 1 && vexRT(Btn8DXmtr2) == 0) //Half court -- 6D = slower
		//		{
		//		//Spin_Flywheels(MID_SWEETSPOT) ;
		//		battDependentHalf_Court_Sweetspot = Lookup_Sweetspot (3) ;
		//		Spin_Flywheels(battDependentHalf_Court_Sweetspot) ;
		//		}
		//	else if(vexRT(Btn6UXmtr2) == 0 && vexRT(Btn6DXmtr2) == 0 && vexRT(Btn8DXmtr2) == 1) //Robot is at bar -- 8D = slow
		//		{
		//		//Spin_Flywheels(BAR_SWEETSPOT) ;
		//		battDependentBar_Sweetspot = Lookup_Sweetspot (1) ;
		//		Spin_Flywheels(battDependentBar_Sweetspot) ;
		//		}
		//	else if(vexRT(Btn6UXmtr2) == 0 && vexRT(Btn6DXmtr2) == 0 && vexRT(Btn8DXmtr2) == 0) //Neither button is pressed -- motors are stopped
		//		{
		//		Spin_Flywheels(0) ;
		//		}
		//	else if(vexRT(Btn6UXmtr2) == 1 && vexRT(Btn6DXmtr2) == 1 && vexRT(Btn8DXmtr2) == 1) //All are pressed -- no confusion -- motors are stopped
		//		{
		//		Spin_Flywheels(0) ;
		//		}


	wait1Msec(1000) ;
	Spin_Flywheels(battDependentSkills_Sweetspot) ;
	wait1Msec(2300) ;

	Move_Conveyors(127) ;
	wait1Msec(550) ;
	Stop_Conveyors();
	wait1Msec(2000) ;

	Move_Conveyors(127) ;
	wait1Msec(1000) ;
	Stop_Conveyors();
	wait1Msec(2000) ;

	Move_Conveyors(127) ;
	wait1Msec(1000) ;
	Stop_Conveyors();
	wait1Msec(2000) ;

	Move_Conveyors(127) ;
	wait1Msec(1000) ;
	Stop_Conveyors();

Stop_All_Motors() ;



				clearTimer(T1) ;
				bool Done = true ;
				string mainS, secondaryS ;	//Holds formatted battery voltage
				battVoltage = SensorValue(powerExpBattery) / 282.66 ;
				mainVoltage = nImmediateBatteryLevel / 1000.0 ;
				clearLCDLine(0); clearLCDLine(1); bLCDBacklight = true;					//Clear LCD lines and turn on backlight

				stringFormat(mainS,   "%1.2f", mainVoltage) ;
				displayLCDString(0, 0, "M:") ;
				displayLCDString(0, 3, mainS) ;
				stringFormat(secondaryS, "%1.2f", battVoltage);
				displayLCDString(0, 8, "S:");
				displayLCDString(0, 11,secondaryS);

				//stringFormat(fullS, "%1.2f", battDependentFull_Court_Sweetspot) ;
				//displayLCDString(1, 1, "F:") ;
				//displayLCDString(1, 3, fullS) ;

				//stringFormat(halfS, "%1.2", battDependentHalf_Court_Sweetspot) ;
				//displayLCDString(1, 6, "H:") ;
				//displayLCDString(1, 9, halfS) ;

				stringFormat(skillS, "%1.2f", battDependentSkills_Sweetspot) ;
				displayLCDString(1, 11, "S:") ;
				displayLCDString(1, 13, skillS) ;

				waitForPress() ;
				if(nLCDButtons == CENTER_BUTTON)
				{
					waitForRelease() ;

					clearLCDLine(1) ;

					Done = false ;
				}

		while(Done == false)
		{
					stringFormat(skillS, "%1.2f", battDependentSkills_Sweetspot) ;
					displayLCDString(1, 1, "D           U") ;
					displayLCDCenteredString(1, skillS) ;

					waitForPress();
					if(nLCDButtons == LEFT_BUTTON)
					{
						waitForRelease();
						battDependentSkills_Sweetspot -= 1;
					}

					else if(nLCDButtons == RIGHT_BUTTON)
					{
						waitForRelease() ;
						battDependentSkills_Sweetspot += 1 ;
					}

					else if(nLCDButtons == CENTER_BUTTON)
					{

						waitForRelease() ;

						Done = true ;

					}

				}



			} // End of timerLock if statement

			timerLock = time1[T1] ;

		} //End of Driver Control While loop
}	//End of usercontrol task


/*

	8.3 =
	8.0 = 45
	7.9 = 46
	7.95 = 47
	7.8 = 46
	7.79 =

*/
