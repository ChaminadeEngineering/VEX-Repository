#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in4,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in5,    ,               sensorLineFollower)
#pragma config(Sensor, in6,    ,               sensorLineFollower)
#pragma config(Sensor, dgtl1,  rightOptics,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  armLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl4,  launcherLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl5,  ultrasonic,     sensorSONAR_inch)
#pragma config(Sensor, dgtl11, leftOptics,     sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  collectorIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightCamIME,    sensorNone)
#pragma config(Sensor, I2C_3,  tensionerIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  rightBaseIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  leftBaseIME,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  leftCamIME,     sensorNone)
#pragma config(Motor,  port1,           tensioner,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port2,           rightFrontBase, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightBackBase, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           rightFrontCam, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightBackCam,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           leftFrontCam,  tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port7,           leftBackCam,   tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_5)
#pragma config(Motor,  port8,           leftFrontBase, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftBackBase,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          collector,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
1: The basic code that has everything it needs as of now
*/

//Speed to make life easier (see DriveBaseControl)
//#define SLOWSPEED 45

float gyroAdjust = false; //If gyroAdjust is true, adjustForJiggle (see button 5UXmtr2/6U in "Worlds.c" and adjustForJiggle)
int gyroValue; //Used in adjustForJiggle to sense the gyro value and compare it to the targetGyroValue

void adjustForJiggle(int targetGyroValue) //Used in "Worlds.c" to readjust the base while doing EPL (see "Worlds.c")
{
	SensorValue[gyro] = gyroValue;
	if(gyroValue > targetGyroValue+6)
	{
		motor[rightBackBase] = -20;
		motor[rightFrontBase] = -20;
		motor[leftFrontBase] = 20;
		motor[leftBackBase] = 20;
	}
	else if(gyroValue < targetGyroValue-6)
	{
		motor[rightBackBase] = 20;
		motor[rightFrontBase] = 20;
		motor[leftFrontBase] = -20;
		motor[leftBackBase] = -20;
	}
	else
	{
		motor[rightBackBase] = 0;
		motor[rightFrontBase] = 0;
		motor[leftFrontBase] = 0;
		motor[leftBackBase] = 0;
	}
}

void setCams(int speed)//Set the Cams to a speed
{
	motor[rightFrontCam] = -speed;
	motor[leftFrontCam] = -speed;
	motor[rightBackCam] = speed;
	motor[leftBackCam] = speed;
}

void driveBaseControl() //Controls the base with Channels 3 and 4
{
	//if(vexRT[Btn8R] == 1)//5 Up - swivel slowly left
	//{
	//	motor[rightFrontBase] = SLOWSPEED;
	//	motor[rightBackBase] = SLOWSPEED;
	//}
	//else if(vexRT[Btn7L] == 1)//6 Up - swivel slowly right
	//{
	//	motor[leftFrontBase] = SLOWSPEED;
	//	motor[leftBackBase] = SLOWSPEED;
	//}
	//else if(vexRT[Btn8D] == 1)//6 Down - swivel slowly backwards right
	//{
	//	motor[rightFrontBase] = -SLOWSPEED;
	//	motor[rightBackBase] = -SLOWSPEED;
	//}
	//else if(vexRT[Btn7D] == 1)//5 Down - swivel slowly backwards left
	//{
	//	motor[leftFrontBase] = -SLOWSPEED;
	//	motor[leftBackBase] = -SLOWSPEED;
	//}
	//else
	//{
		motor[rightFrontBase] = vexRT[Ch3];
		motor[rightBackBase] = vexRT[Ch3];
		motor[leftFrontBase] = vexRT[Ch2];
		motor[leftBackBase] = vexRT[Ch2];
	//}
}


void auton()//Move forward a little and launch 4 balls using 2 limit switches
{
	SensorValue(rightOptics) = 0;
	SensorValue(leftOptics) = 0;
	//resetMotorEncoder();
	//resetMotorEncoder();
	//	motor[rightFrontBase] = 35;
	//	motor[rightBackBase] = 35;
	//	motor[leftFrontBase] = 35;
	//	motor[leftBackBase] = 35;
	//	wait1Msec(900);
	//	motor[rightFrontBase] = 0;
	//	motor[rightBackBase] = 0;
	//	motor[leftFrontBase] = 0;
	//	motor[leftBackBase] = 0;

	//1ST BALL
	/*If the limit switch on the arm is not pressed,
	it wll move the cams until it is, causing the cams to be all the way down.
	Then, it will turn the cams off and wait for 250 milliseconds.*/
	while(SensorValue[armLimitSwitch] != 1)
	{
		setCams(90);
	}
	setCams(0);
	wait1Msec(250);

	/*If the limit switch on the launcher is not pressed,
	it will move the collector until a ball enters and it is.
	Then, it will turn off the collector, wait 250 milliseconds,
	and turn on the cams for 500 milliseconds to launch the ball.*/
	while(SensorValue[launcherLimitSwitch] != 1)
	{
		motor[backcollector] = 100;
		motor[frontcollector] = 100;
	}
	motor[backcollector] = 0;
	motor[frontcollector] = 0;
	wait1Msec(700);
	setCams(90);
	wait1Msec(500);
	setCams(0);


	//2ND BALL
	/*If the limit switch on the arm is not pressed,
	it wll move the cams until it is, causing the cams to be all the way down.
	Then, it will turn the cams off and wait for 250 milliseconds.*/
	while(SensorValue[armLimitSwitch] != 1)
	{
		setCams(90);
	}
	setCams(0);
	wait1Msec(250);

	/*If the limit switch on the launcher is not pressed,
	it will move the collector until a ball enters and it is.
	Then, it will turn off the collector, wait 250 milliseconds,
	and turn on the cams for 500 milliseconds to launch the ball.*/
	while(SensorValue[launcherLimitSwitch] != 1)
	{
		motor[backcollector] = 100;
		motor[frontcollector] = 100;
	}
	motor[backcollector] = 0;
	motor[frontcollector] = 0;
	wait1Msec(700);
	setCams(90);
	wait1Msec(500);
	setCams(0);


	//3RD BALL
	/*If the limit switch on the arm is not pressed,
	it wll move the cams until it is, causing the cams to be all the way down.
	Then, it will turn the cams off and wait for 250 milliseconds.*/
	while(SensorValue[armLimitSwitch] != 1)
	{
		setCams(90);
	}
	setCams(0);
	wait1Msec(250);

	/*If the limit switch on the launcher is not pressed,
	it will move the collector until a ball enters and it is.
	Then, it will turn off the collector, wait 250 milliseconds,
	and turn on the cams for 500 milliseconds to launch the ball.*/
	while(SensorValue[launcherLimitSwitch] != 1)
	{
		motor[backcollector] = 100;
		motor[frontcollector] = 100;
	}
	motor[backcollector] = 0;
	motor[frontcollector] = 0;
	wait1Msec(700);
	setCams(90);
	wait1Msec(500);
	setCams(0);


	//4TH BALL
	/*If the limit switch on the arm is not pressed,
	it wll move the cams until it is, causing the cams to be all the way down.
	Then, it will turn the cams off and wait for 250 milliseconds.*/
	while(SensorValue[armLimitSwitch] != 1)
	{
		setCams(90);
	}
	setCams(0);
	wait1Msec(250);

	/*If the limit switch on the launcher is not pressed,
	it will move the collector until a ball enters and it is.
	Then, it will turn off the collector, wait 250 milliseconds,
	and turn on the cams for 500 milliseconds to launch the ball.*/
	while(SensorValue[launcherLimitSwitch] != 1)
	{
		motor[backcollector] = 100;
		motor[frontcollector] = 100;
	}
	motor[backcollector] = 0;
	motor[frontcollector] = 0;
	wait1Msec(700);
	setCams(90);
	wait1Msec(500);
	setCams(0);
	/*If the limit switch on the arm is not pressed,
	it wll move the cams until it is, causing the cams to be all the way down.
	Then, it will turn the cams off and wait for 250 milliseconds.*/
	while(SensorValue[armLimitSwitch] != 1)
	{
		setCams(90);
	}
	setCams(0);
	wait1Msec(250);
	motor[rightFrontBase] = 0;
	motor[rightBackBase] = 0;
	motor[leftFrontBase] = 0;
	motor[leftBackBase] = 0;
}

void skills()//Launch 32 balls (EPL), turn left, move forward, turn back right (getting to the other launching zone) and launch the other 32 balls
{
	//	int count = 0;
	//	while(count << 3)
	//	{
	//		setCams(127);
	//		if(SensorValue[armLimitSwitch] == 1)
	//		{
	//			count++;
	//		}
	//	}
	//	setCams(0);

	//setCams(127);
	//wait1Msec(however long we need);

	//GYRO TURNING - LEFT TURN
	SensorType[gyro] = sensorNone;
	wait1Msec(1000);
	SensorType[gyro] = sensorGyro;
	wait1Msec(1000);
	while(abs(SensorValue[gyro]) < 750)
	{
		motor[rightBackBase] = -35;
		motor[rightFrontBase] = -35;
		motor[leftFrontBase] = 35;
		motor[leftBackBase] = 35;
	}
	motor[rightBackBase] = 0;
	motor[rightFrontBase] = 0;
	motor[leftFrontBase] = 0;
	motor[leftBackBase] = 0;

	resetMotorEncoder(rightFrontBase);
	resetMotorEncoder(leftBackBase);
	while(SensorValue[rightBaseIME] < 100) //needs changing
	{
		if(SensorValue[rightBaseIME] < SensorValue[leftBaseIME])
		{
			motor[rightBackBase] = 70;
			motor[rightFrontBase] = 70;
			motor[leftFrontBase] = 65;
			motor[leftBackBase] = 65;
		}
		else if(SensorValue[rightBaseIME] > SensorValue[leftBaseIME])
		{
			motor[rightBackBase] = 65;
			motor[rightFrontBase] = 65;
			motor[leftFrontBase] = 70;
			motor[leftBackBase] = 70;
		}
		else
		{
			motor[rightBackBase] = 80;
			motor[rightFrontBase] = 80;
			motor[leftFrontBase] = 80;
			motor[leftBackBase] = 80;
		}
	}

	SensorValue[gyro] = 0;
	while(abs(SensorValue[gyro]) < 900)
	{
		motor[rightBackBase] = 35;
		motor[rightFrontBase] = 35;
		motor[leftFrontBase] = -35;
		motor[leftBackBase] = -35;
	}
	motor[rightBackBase] = 0;
	motor[rightFrontBase] = 0;
	motor[leftFrontBase] = 0;
	motor[leftBackBase] = 0;
	//setCams(127);

	//OPTIC TURNING
	//SensorValue[rightOptics] = 0;
	//SensorValue[leftOptics] = 0;
	//while(SensorValue[rightOptics] > -300)
	//{
	//	//turn right
	//	motor[rightBackBase] = 50;
	//	motor[rightFrontBase] = 50;
	//	motor[leftFrontBase] = -50;
	//	motor[leftBackBase] = -50;
	//}
	//motor[rightBackBase] = 0;
	//motor[rightFrontBase] = 0;
	//motor[leftFrontBase] = 0;
	//motor[leftBackBase] = 0;
	//wait1Msec(500);
}
