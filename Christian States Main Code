#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in5,    ,               sensorLineFollower)
#pragma config(Sensor, in6,    ,               sensorLineFollower)
#pragma config(Sensor, dgtl1,  rightOptics,    sensorRotation)
#pragma config(Sensor, dgtl2,  leftOptics,     sensorRotation)
#pragma config(Sensor, dgtl3,  armLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl4,  launcherLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl5,  LEDLine,        sensorDigitalOut)
#pragma config(Sensor, dgtl12, ,               sensorDigitalOut)
#pragma config(Sensor, I2C_1,  collectorIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightCamIME,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  tensionerIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  rightBaseIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  leftBaseIME,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  leftCamIME,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftcollector, tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port2,           rightFrontBase, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port3,           rightBackBase, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_6)
#pragma config(Motor,  port4,           rightFrontCam, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rightBackCam,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           leftFrontCam,  tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port7,           leftBackCam,   tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port8,           leftFrontBase, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftBackBase,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightcollector, tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define CAMSPEED 127 //This is the speed of the cams, later used in the code
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "New_Autons_And_Functions.c"

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	auton();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	while(true)
	{
		//6 Up 2nd Remote - Resetting the Cams and Loading a Ball using 2 Limits
		//if(vexRT[Btn6UXmtr2] == 1)
		//{
		//	while(SensorValue[armLimitSwitch] != 1)
		//	{
		//		//Drive Base Logic
		//		driveBaseControl();
		//		motor[leftFrontCam] = -127;
		//		motor[rightFrontCam] = -127;
		//		motor[leftBackCam] = 127;
		//		motor[rightBackCam] = 127;
		//	}
		//	motor[rightFrontCam] = 0;
		//	motor[leftFrontCam] = 0;
		//	motor[rightBackCam] = 0;
		//	motor[leftBackCam] = 0;
		//if(SensorValue[launcherLimitSwitch] != 1)
		//{
		//	driveBaseControl();
		//	motor[leftCollector] = 127;
		//	motor[rightCollector] = 127;
		//	wait1Msec(3000);
		//}
		//	motor[collector] = 0;
		//}

		if(vexRT[Btn6UXmtr2] == 1)
		{
			while(SensorValue[armLimitSwitch] != 1)
			{
				//Drive Base Logic
				driveBaseControl();
				motor[leftFrontCam] = -127;
				motor[rightFrontCam] = -127;
				motor[leftBackCam] = 127;
				motor[rightBackCam] = 127;
			}
			motor[rightFrontCam] = 0;
			motor[leftFrontCam] = 0;
			motor[rightBackCam] = 0;
			motor[leftBackCam] = 0;
			//if(SensorValue[launcherLimitSwitch] != 1)
			//{
			//	driveBaseControl();
			//	motor[leftCollector] = 127;
			//	motor[rightCollector] = 127;
			//	wait1Msec(3000);
			//}
			motor[rightcollector] = 0;
			motor[leftcollector] = 0;
		}

		//5 Up 2nd Remote - Manual Cams control
		if(vexRT[Btn5UXmtr2] == 1)
		{
			motor[rightFrontCam] = -CAMSPEED;
			motor[leftFrontCam] = -CAMSPEED;
			motor[rightBackCam] = CAMSPEED;
			motor[leftBackCam] = CAMSPEED;
		}
		else if(vexRT[Btn6U] == 1)
		{
			motor[rightFrontCam] = -CAMSPEED;
			motor[leftFrontCam] = -CAMSPEED;
			motor[rightBackCam] = CAMSPEED;
			motor[leftBackCam] = CAMSPEED;
		}
		else
		{
			motor[rightFrontCam] = 0;
			motor[leftFrontCam] = 0;
			motor[rightBackCam] = 0;
			motor[leftBackCam] = 0;
		}

		if(vexRT[Btn8DXmtr2] == 1)
		{
			motor[leftFrontCam] = -127;
			motor[rightFrontCam] = -127;
			motor[leftBackCam] = 127;
			motor[rightBackCam] = 127;
			wait1Msec(200);
			while(SensorValue[armLimitSwitch] != 1)
			{
				//Drive Base Logic
				driveBaseControl();
				motor[leftFrontCam] = -127;
				motor[rightFrontCam] = -127;
				motor[leftBackCam] = 127;
				motor[rightBackCam] = 127;
			}
			motor[rightFrontCam] = 0;
			motor[leftFrontCam] = 0;
			motor[rightBackCam] = 0;
			motor[leftBackCam] = 0;
		}

		if(vexRT[Btn8RXmtr2] == 1)
		{
			motor[leftFrontCam] = -127;
			motor[rightFrontCam] = -127;
			motor[leftBackCam] = 127;
			motor[rightBackCam] = 127;
			wait1Msec(200);
			while(SensorValue[armLimitSwitch] != 1)
			{
				//Drive Base Logic
				driveBaseControl();
				motor[leftFrontCam] = -127;
				motor[rightFrontCam] = -127;
				motor[leftBackCam] = 127;
				motor[rightBackCam] = 127;
			}
			motor[rightFrontCam] = 0;
			motor[leftFrontCam] = 0;
			motor[rightBackCam] = 0;
			motor[leftBackCam] = 0;
			int count = 1;
			while(SensorValue[launcherLimitSwitch] != 1 && count == 1)
			{
				driveBaseControl();
				motor[rightcollector] = 127;
				motor[leftcollector] = 127;
				if(vexRT[Btn8UXmtr2] == 1)
				{
					count = 0;
				}
			}
			motor[rightcollector] = 0;
			motor[leftcollector] = 0;
		}
		motor[rightcollector] = -vexRT[Ch3Xmtr2];
		motor[leftcollector] = -vexRT[Ch3Xmtr2];

		//8r and 7l are forwards, 8d and 7d are right and left back, triggers are 6u collect in, 5u is out, 6d is cams, 5d is w/ limit switches

		//Channel whatever on whichever remote - Tensioner
		//if(vexRT[Btn7UXmtr2] == 1)
		//{
		//	motor[tensioner] = 127;
		//}
		//else if(vexRT[Btn7DXmtr2] == 1)
		//{
		//	motor[tensioner] = -127;
		//}
		//else
		//{
		//	motor[tensioner] = -20;
		//}

		driveBaseControl();//See "New_Autons_And_Functions.c"
	}
}
